


@{
    ViewData["Title"] = "Upload Meter Readings";
    Layout = "~/Views/Shared/_DashboardLayout.cshtml";
}

<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" />

<div class="container mt-5">
    <h3 class="mb-4">
        <i class="bi bi-upload"></i> Upload Meter Readings
    </h3>

    <form id="uploadForm" enctype="multipart/form-data">
        <div class="mb-3">
            <label for="csvFile" class="form-label">Select CSV File</label>
            <input type="file" class="form-control" id="csvFile" accept=".csv" required />
        </div>
        <button type="submit" class="btn btn-success">Upload</button>
    </form>

    <p id="uploadMsg" class="mt-3"></p>
</div>

<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

<script>
    const apiUrl = "https://localhost:7285/api/MeterReading";  // Your API base for meter readings
    const token = localStorage.getItem("jwtToken");

    $('#uploadForm').submit(async function(event) {
        event.preventDefault();
        const fileInput = $('#csvFile')[0];

        if (!fileInput.files.length) {
            showMessage("Please select a CSV file to upload.", false);
            return;
        }

        const file = fileInput.files[0];
        if (!file.name.endsWith('.csv')) {
            showMessage("Only .csv files are allowed.", false);
            return;
        }

        try {
            const text = await file.text();
            const meterReadingsArray = parseCSVToJSON(text);

            if (!meterReadingsArray.length) {
                showMessage("CSV is empty or improperly formatted.", false);
                return;
            }

            for (let mr of meterReadingsArray) {
                const response = await fetch(`${apiUrl}/addMeterReadings`, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "Authorization": "Bearer " + token
                    },
                    body: JSON.stringify(mr)
                });

                if (!response.ok) {
                    const errText = await response.text();
                    throw new Error(`Failed to upload reading for MeterId ${mr.meterId}: ${errText}`);
                }
            }

            showMessage(`✅ Successfully uploaded ${meterReadingsArray.length} meter readings!`, true);
            $('#uploadForm')[0].reset();

        } catch (error) {
            showMessage(error.message, false);
            console.error(error);
        }
    });

    function showMessage(msg, success) {
        $('#uploadMsg').text(msg)
            .removeClass('text-danger text-success')
            .addClass(success ? 'text-success' : 'text-danger');
    }

    // Parse CSV to JSON with only MeterId, ReadingValue, ReadingDate
    function parseCSVToJSON(csvText) {
        const lines = csvText.trim().split('\n');
        if (lines.length < 2) return []; // No data

        const headers = lines[0].split(',').map(h => h.trim().toLowerCase());
        const meterIdIdx = headers.indexOf('meterid');
        const readingValueIdx = headers.indexOf('readingvalue');
        const readingDateIdx = headers.indexOf('readingdate');

        if (meterIdIdx === -1 || readingValueIdx === -1 || readingDateIdx === -1) {
            throw new Error("CSV must include columns: MeterId,ReadingValue,ReadingDate");
        }

        const data = lines.slice(1).map(line => {
            const cols = line.split(',');
            return {
                meterId: parseInt(cols[meterIdIdx]),
                readingValue: parseFloat(cols[readingValueIdx]),
                readingDate: new Date(cols[readingDateIdx]).toISOString()
            };
        });

        // Filter invalid entries
        return data.filter(d =>
            !isNaN(d.meterId) &&
            !isNaN(d.readingValue) &&
            !isNaN(new Date(d.readingDate))
        );
    }
</script>
